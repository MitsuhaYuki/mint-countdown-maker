# 倒计时视频生成器 - 开发指南

> 面向开发者的技术文档

## 📖 目录

- [开发环境](#开发环境)
- [项目架构](#项目架构)
- [核心技术](#核心技术)
- [开发流程](#开发流程)
- [构建发布](#构建发布)
- [扩展开发](#扩展开发)

---

## 开发环境

### 系统要求
- Node.js 16+
- npm 或 yarn
- Git

### 快速开始

```bash
# 克隆项目
git clone <repository-url>
cd mint-countdown-maker

# 安装依赖
npm install

# 启动开发服务器
npm run dev
```

### 推荐工具
- **VSCode** - 代码编辑器
- **ESLint** - 代码检查
- **React DevTools** - React 调试

---

## 项目架构

### 技术栈
- **Electron 38** - 桌面应用框架
- **React 19** - UI 框架
- **Vite 7** - 构建工具
- **Canvas API** - 图形渲染
- **WebCodecs API** - 视频编码

### 目录结构

```
src/
├── main/                   # Electron 主进程
│   └── index.js           # IPC 处理、系统 API
├── preload/               # 预加载脚本
│   └── index.js           # 安全的 IPC 桥接
└── renderer/              # React 渲染进程
    └── src/
        ├── App.jsx                    # 主应用逻辑
        ├── components/
        │   ├── CountdownPreview.jsx   # 预览组件
        │   └── CountdownConfig.jsx    # 配置组件
        └── utils/
            ├── videoExporter.js       # 视频导出
            └── configHelp.js          # 配置帮助文本
```

### 进程通信 (IPC)

**主进程 API** (`main/index.js`)：
```javascript
// 获取系统字体
ipcMain.handle('get-system-fonts', async () => {
  const fonts = await fontList.getFonts()
  return fonts
})

// 选择背景图片
ipcMain.handle('select-background-image', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [{ name: 'Images', extensions: ['jpg', 'png', 'gif'] }]
  })
  // 返回 base64 图片数据
})

// 保存视频文件
ipcMain.handle('save-video-file', async (event, filePath, buffer) => {
  await fs.promises.writeFile(filePath, buffer)
  return { success: true }
})
```

**预加载脚本** (`preload/index.js`)：
```javascript
const api = {
  getSystemFonts: () => ipcRenderer.invoke('get-system-fonts'),
  selectBackgroundImage: () => ipcRenderer.invoke('select-background-image'),
  saveVideoDialog: () => ipcRenderer.invoke('save-video-dialog'),
  saveVideoFile: (filePath, buffer) => 
    ipcRenderer.invoke('save-video-file', filePath, buffer)
}

contextBridge.exposeInMainWorld('api', api)
```

**渲染进程调用**：
```javascript
const fonts = await window.api.getSystemFonts()
const imageData = await window.api.selectBackgroundImage()
```

---

## 核心技术

### 1. Canvas 渲染

**实时预览** (`CountdownPreview.jsx`)：

```javascript
useEffect(() => {
  const canvas = canvasRef.current
  const ctx = canvas.getContext('2d')
  
  // 1. 绘制背景
  ctx.fillStyle = config.backgroundColor
  ctx.fillRect(0, 0, canvas.width, canvas.height)
  
  // 2. 绘制背景图片
  if (backgroundImage) {
    const size = config.backgroundSize || 'cover'
    // 计算缩放和位置
    ctx.drawImage(img, x, y, drawWidth, drawHeight)
  }
  
  // 3. 应用混合模式
  if (config.blendMode !== 'none') {
    ctx.globalCompositeOperation = config.blendMode
  }
  
  // 4. 绘制文字
  ctx.font = `${config.fontSize}px "${config.fontFamily}"`
  ctx.fillStyle = config.fontColor
  
  // 应用阴影
  if (config.textShadowEnabled) {
    ctx.shadowColor = config.textShadowColor
    ctx.shadowBlur = config.textShadowBlur
    ctx.shadowOffsetX = config.textShadowOffsetX
    ctx.shadowOffsetY = config.textShadowOffsetY
  }
  
  ctx.fillText(text, posX, posY)
  
  // 重置混合模式
  ctx.globalCompositeOperation = 'source-over'
}, [config, countdown])
```

### 2. 视频导出

**使用 WebCodecs API** (`App.jsx`)：

```javascript
import { VideoExporter } from './utils/videoExporter'

const handleExportVideo = async () => {
  const exporter = new VideoExporter(tempCanvas)
  
  // 配置编码器
  await exporter.startRecording(config.fps, config.bitrate)
  
  // 逐帧渲染
  const totalFrames = config.totalSeconds * config.fps
  for (let frame = 0; frame < totalFrames; frame++) {
    const currentSecond = Math.floor(frame / config.fps)
    const remainingSeconds = config.totalSeconds - currentSecond
    
    // 绘制背景和文字
    drawBackground()
    drawCountdownText(remainingSeconds)
    
    // 添加帧到编码器
    await exporter.addFrame()
    
    // GPU 资源管理
    if (frame % 100 === 0) {
      await new Promise(resolve => setTimeout(resolve, 50))
    }
  }
  
  // 获取视频数据
  const blob = await exporter.stopRecording()
  
  // 保存文件
  const arrayBuffer = await blob.arrayBuffer()
  await window.api.saveVideoFile(filePath, new Uint8Array(arrayBuffer))
}
```

**VideoExporter 类** (`utils/videoExporter.js`)：

```javascript
export class VideoExporter {
  async startRecording(fps, bitrate) {
    const stream = this.canvas.captureStream(fps)
    const track = stream.getVideoTracks()[0]
    
    // 配置 H.264 编码器
    this.encoder = new VideoEncoder({
      output: (chunk, metadata) => {
        this.chunks.push(chunk)
      },
      error: (e) => console.error(e)
    })
    
    this.encoder.configure({
      codec: 'avc1.42E01E',
      width: this.canvas.width,
      height: this.canvas.height,
      bitrate: bitrate * 1000000,
      framerate: fps,
      latencyMode: 'quality'
    })
  }
  
  async stopRecording() {
    await this.encoder.flush()
    // 使用 mp4-muxer 打包为 MP4
    return this.muxer.finalize()
  }
}
```

### 3. 倒计时格式化

**经典格式**：
```javascript
function formatCountdownText(countdown, config) {
  const { hours, minutes, seconds } = countdown
  const { hourFormat, minuteFormat, secondFormat, separator } = config
  
  const parts = []
  
  // 处理小时
  if (hourFormat === 'auto') {
    if (hours > 0) parts.push(hours.toString())
  } else if (hourFormat === 'show') {
    parts.push(hours.toString())
  } else if (hourFormat === 'two-digits') {
    parts.push(hours.toString().padStart(2, '0'))
  }
  
  // 同样处理分钟和秒
  // ...
  
  return parts.join(separator || ':')
}
```

**纯数字格式**：
```javascript
if (config.formatMode === 'pure-number') {
  const totalSeconds = hours * 3600 + minutes * 60 + seconds
  return totalSeconds.toString()
}
```

### 4. 背景图片处理

**Cover 模式**：
```javascript
if (size === 'cover') {
  if (imgRatio > canvasRatio) {
    // 图片更宽，以高度为准
    drawHeight = canvas.height
    drawWidth = canvas.height * imgRatio
    x = (canvas.width - drawWidth) / 2
    y = 0
  } else {
    // 图片更高，以宽度为准
    drawWidth = canvas.width
    drawHeight = canvas.width / imgRatio
    x = 0
    y = (canvas.height - drawHeight) / 2
  }
}
```

**Contain 模式**：
```javascript
if (size === 'contain') {
  if (imgRatio > canvasRatio) {
    // 图片更宽，以宽度为准
    drawWidth = canvas.width
    drawHeight = canvas.width / imgRatio
    x = 0
    y = (canvas.height - drawHeight) / 2
  } else {
    // 图片更高，以高度为准
    drawHeight = canvas.height
    drawWidth = canvas.height * imgRatio
    x = (canvas.width - drawWidth) / 2
    y = 0
  }
}
```

### 5. 配置帮助系统

**集中式管理** (`utils/configHelp.js`)：
```javascript
export const configHelp = {
  fontFamily: '选择系统中已安装的字体...',
  fontSize: '设置倒计时文字的大小...',
  blendMode: '混合模式可以让文字根据背景自动调整颜色...',
  backgroundSize: 'Cover会填满画布，Contain会完整显示图片...',
  // ... 21 个配置项
}
```

**在组件中使用**：
```javascript
import { configHelp } from '../utils/configHelp'

<label title={configHelp.fontFamily}>字体：</label>
```

---

## 开发流程

### 添加新配置项

**步骤 1：更新配置状态** (`App.jsx`)
```javascript
const [config, setConfig] = useState({
  // 现有配置...
  newOption: 'default-value'  // 新增
})
```

**步骤 2：添加 UI 控件** (`CountdownConfig.jsx`)
```javascript
<div className="config-item">
  <label title={configHelp.newOption}>新选项：</label>
  <select
    value={config.newOption}
    onChange={(e) => onConfigChange({ ...config, newOption: e.target.value })}
  >
    <option value="option1">选项1</option>
    <option value="option2">选项2</option>
  </select>
</div>
```

**步骤 3：应用到渲染** (`CountdownPreview.jsx`)
```javascript
// 在绘制逻辑中使用新配置
if (config.newOption === 'option1') {
  // 特定处理
}
```

**步骤 4：应用到导出** (`App.jsx`)
```javascript
// 在导出逻辑中同步处理
```

**步骤 5：添加帮助文本** (`utils/configHelp.js`)
```javascript
export const configHelp = {
  // ...
  newOption: '这是新选项的说明...'
}
```

### 调试技巧

**开启开发者工具**：
```javascript
// 按 F12 或在代码中
mainWindow.webContents.openDevTools()
```

**查看主进程日志**：
- 终端输出
- `console.log()` 语句

**Canvas 调试**：
```javascript
// 将临时 canvas 添加到页面
document.body.appendChild(tempCanvas)
tempCanvas.style.cssText = 'position:fixed;top:0;left:0;z-index:9999'
```

**性能分析**：
```javascript
console.time('export')
// 导出代码
console.timeEnd('export')
```

---

## 构建发布

### 构建命令

```bash
# Windows
npm run build:win

# macOS
npm run build:mac

# Linux
npm run build:linux
```

### 构建配置 (`electron-builder.yml`)

```yaml
appId: com.example.countdown-maker
productName: Countdown Maker
directories:
  output: release/${version}

win:
  target:
    - nsis
  icon: build/icon.ico

mac:
  target:
    - dmg
  icon: build/icon.icns
  category: public.app-category.video

linux:
  target:
    - AppImage
    - deb
  icon: build/icon.png
  category: Video
```

### 版本发布流程

1. 更新 `package.json` 版本号
2. 更新 `docs/更新日志.md`
3. 提交代码并打 tag
4. 运行构建命令
5. 上传安装包到 Releases

---

## 扩展开发

### 添加新混合模式

```javascript
// CountdownConfig.jsx
<select value={config.blendMode}>
  <option value="none">无</option>
  <option value="new-mode">新模式</option>
</select>

// CountdownPreview.jsx
ctx.globalCompositeOperation = config.blendMode
```

### 支持新视频格式

修改 `VideoExporter` 类中的编码器配置：
```javascript
this.encoder.configure({
  codec: 'vp09.00.10.08',  // VP9 编码
  // 其他配置
})
```

### 添加国际化支持

基于现有 `configHelp` 架构：
```javascript
// utils/i18n.js
const translations = {
  'zh-CN': configHelp,
  'en-US': configHelpEN
}

export function t(key) {
  return translations[currentLocale][key]
}

// 使用
<label title={t('fontFamily')}>Font:</label>
```

### 优化性能

**长视频导出优化**：
```javascript
// 每 N 帧让渡 GPU
if (frameCount % 100 === 0) {
  await new Promise(resolve => setTimeout(resolve, 50))
}

// 限制编码器队列
while (encoder.encodeQueueSize > 5) {
  await new Promise(resolve => setTimeout(resolve, 10))
}
```

---

## 代码规范

### ESLint 配置

项目使用 ESLint 进行代码检查：
```bash
npm run lint
```

### 组件规范

- 使用函数组件和 Hooks
- Props 解构在函数参数中
- 使用 `useEffect` 处理副作用
- 状态提升到父组件

### 命名规范

- 组件：PascalCase（`CountdownPreview`）
- 函数：camelCase（`formatCountdownText`）
- 常量：UPPER_CASE（`MAX_DURATION`）
- CSS 类：kebab-case（`config-item`）

---

## 技术限制

1. **视频格式**：仅支持 MP4（H.264）
2. **浏览器要求**：需支持 WebCodecs API
3. **GPU 依赖**：长视频导出需要良好的 GPU 支持
4. **字体渲染**：依赖系统字体，Canvas 渲染可能与系统略有差异

---

## 贡献指南

1. Fork 项目
2. 创建功能分支 (`git checkout -b feature/AmazingFeature`)
3. 提交更改 (`git commit -m 'Add some AmazingFeature'`)
4. 推送到分支 (`git push origin feature/AmazingFeature`)
5. 开启 Pull Request

---

## 相关资源

- [Electron 文档](https://www.electronjs.org/docs)
- [React 文档](https://react.dev/)
- [Canvas API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)
- [WebCodecs API](https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API)

---

**祝开发愉快！** 🚀
